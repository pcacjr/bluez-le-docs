\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{fancyhdr}

\pagestyle{fancy}
\lhead{}
\chead{}
\rhead{}
\fancyfoot[C] {This document is confidential}
\fancyfoot[R] {\thepage}
\fancyhead[C] {BlueZ BTLE How-To}
\fancyhead[R] {\thepage}

\setlength{\parskip}{10pt}

\title{BlueZ BTLE How-To} \author{Jo√£o Paulo Rechi Vita \\
                                  jprvita@openbossa.org
                          \and
                          Paulo Alcantara \\
                          paulo.alcantara@openbossa.org
			  \and
			  Claudio Takahasi \\
			  claudio.takahasi@openbossa.org}

\begin{document}

\maketitle
\newpage

\tableofcontents
\newpage

\section{Introduction}

This document describes how to test and use Bluetooth Low-Energy on Linux
systems, using the most recent implementation available at the moment of this
writing. The instructions are based on a Ubuntu Linux 11.10, since its the most
widely deployed Linux distribution nowadays. Nonetheless, the process for other
distributions should be very similar.

\section{Dependencies}

Bellow are listed the libraries and tools needed to compile BlueZ for BTLE
development. The list uses the packages name on Ubuntu 11.10.

\begin{itemize}
 \item git
 \item automake
 \item byacc
 \item flex
 \item libtool
 \item libdbus-1-dev
 \item libglib2.0-dev
 \item libcap-ng-dev
 \item libusb-dev
 \item libudev-dev
 \item libreadline-dev
\end{itemize}

To install packages on Ubuntu, use \verb|apt-get|, like shown bellow.

\begin{verbatim}
$ sudo apt-get install <package>
\end{verbatim}

Make sure you have {\em libreadline-dev} installed, otherwise \verb|gatttoll| is not
built.

\section{Getting the source code}

\subsection{Linux kernel}

BTLE development is focused on the new Management API, which requires a very
recent kernel tree. The most up-to-date kernel tree with several LE-specific
fixes can be found on the {\em integration} branch of the following tree on
GitHub. Eventually this branch will be integrated on the official kernel trees.
Don't bother trying to compile other branches, since they have experimental
changes. To access this code, clone the tree and checkout the branch:

Additionally, one should take special care when doing changes on top of this
branch, since it's going to be constantly rebased on top of the {\em
bluetooth-next} kernel tree.

\begin{verbatim}
$ git clone git://github.com/aguedes/linux.git
$ cd linux
$ git checkout integration
\end{verbatim}

\subsection{Userspace}

The upstream BlueZ tree has all the code necessary for testing and do further
BTLE development on Linux.

\begin{verbatim}
$ git clone git://git.kernel.org/pub/scm/bluetooth/bluez.git
\end{verbatim}

\section{Building and running}

\subsection{Linux kernel}

Now, copy the Linux kernel configuration file from Ubuntu as \verb|.config| to
the Linux kernel sources directory, and generate a new configuration based on
the Ubuntu one.

\begin{verbatim}
$ cd linux
$ cp /boot/config-`uname -r` .config
$ make oldconfig
\end{verbatim}

You should just press Enter for each question until this command returns. Now
you're ready to compile your kernel. To build and generate a Debian package
that can be installed on Ubuntu the packages {\em fakeroot} and {\em dpkg-dev}
are needed.  Make sure they're installed and run:

\begin{verbatim}
$ make deb-pkg
\end{verbatim}

Then install the new kernel packages with {\em dpkg}:

FIXME: howto load bluetooth module with mgmt enabled

\begin{verbatim}
$ cd ..
$ sudo dpkg -i linux-image* linux-headers*
\end{verbatim}

After the installation is complete, reboot to use the new kernel.

\subsection{Userspace}

BlueZ has a script that does the {\em bootstrap} and {\em configure} phases
with the recommended options for developers. Using it will ease the test and
development processes and is highly recommended. After downloading the source
code, run this script to prepare for compilation.

\begin{verbatim}
$ cd bluez
$ ./bootstrap-configure
\end{verbatim}

Due to a bug in Debian (thus Ubuntu) packaging, if you have the {\em check}
package installed you have to pass the link flag for the correct version of
{\em libcheck}.

\begin{verbatim}
CHECK_LIBS="-lcheck_pic" ./bootstrap-configure
\end{verbatim}

And then build the binaries with {\em make}.

\begin{verbatim}
$ make
\end{verbatim}

Now you're ready to run the Bluetooth daemon you've just compiled. First stop
the one that came with you distro:

\begin{verbatim}
$ sudo service bluetooth stop
\end{verbatim}

And then manually start it from the source tree, without forking into a daemon
(n) and with debug enabled (d).

\begin{verbatim}
$ sudo src/bluetoothd -nd
\end{verbatim}

\section{Testing Management Interface}

Bluetooth Management Interface is a replacement for the traditional HCI
interface, it is a new kernel/userspace API. It aims to move some core host
features to the kernel hiding from the userspace some hardware/controller
specific features. It will NOT be a 1 to 1 HCI command mapping, the idea is
to group a set o HCI commands in one management command.

Management Interface usage is transparent to the userspace. BlueZ supports
an abstraction to hide from the user the active interface.

\begin{verbatim}
'Y' if Management Interface is enabled
cat /sys/module/bluetooth/parameters/enable_mgmt

'Y' if Bluetooth Low Energy is enabled
cat /sys/module/bluetooth/parameters/enable_le
\end{verbatim}

describe here how to pair and start discovery using btmgmt


\section{Enabling debug}

howto enable kernel debug: dmesg debug level, dynamic debug

\begin{verbatim}

modprobe bluetooth enable_le=1 enable_mgmt=1
dmesg -n 7

echo "file net/bluetooth/smp.c +pf\" >> /sys/kernel/debug/dynamic_debug/control
echo "file net/bluetooth/mgmt.c +pf\" >> /sys/kernel/debug/dynamic_debug/control
echo "file net/bluetooth/hci_sock.c +pf\" >> /sys/kernel/debug/dynamic_debug/control
echo "file net/bluetooth/hci_event.c +pf\" >> /sys/kernel/debug/dynamic_debug/control
echo "file net/bluetooth/hci_core.c +pf\" >> /sys/kernel/debug/dynamic_debug/control
echo "file net/bluetooth/hci_conn.c +pf\" >> /sys/kernel/debug/dynamic_debug/control
echo "file net/bluetooth/l2cap_sock.c +pf\" >> /sys/kernel/debug/dynamic_debug/control
echo "file net/bluetooth/l2cap_core.c +pf\" >> /sys/kernel/debug/dynamic_debug/control
\end{verbatim}

\section{Testing using Python scripts}

The test-device is a Python script for testing purposes only and which is part
of the BlueZ toolchain. Through the D-Bus API in Python, the script
will be able to gain access to the D-Bus's system service called
org.bluez and then will have access to the methods (available in the
Interfaces) so that each command will basically call a method of any
specific Interface to list Bluetooth devices, and so on, for example.

For BlueZ, the device "object" represents the remote Bluetooth device.
CreateDevice or CreatePairedDevice is the starting point to access
remote device's services.

There are basically 11 operations that you can perform with test-device script:
\begin{enumerate}
  \item List all known Bluetooth devices.
    \begin{verbatim}
      $ test-device list
    \end{verbatim}
  \item List GATT services from a given device.
    \begin{verbatim}
      $ test-device services <Bluetooth address>
    \end{verbatim}
  \item Create a remote device from a given Bluetooth address. Triggers the
	  SDP or discover all primary services.
    \begin{verbatim}
      $ test-device create <Bluetooth address>
    \end{verbatim}
  \item Remove a device from either a Bluetooth address or a path in
        D-Bus's object path form.
    \begin{verbatim}
      $ test-device remove <Bluetooth address or Service object path>
    \end{verbatim}
  \item Disconnect a remote device.
    \begin{verbatim}
      $ test-device disconnect <Bluetooth address>
    \end{verbatim}
  \item Discover a device from a given Bluetooth address and also an
        optional pattern string. If this option argument is the string
        ``yes'', for example, then the DiscoverDevices() method of the
        org.bluez.Device interface will be called and find presumably
        the device that matches this pattern. Method used to update the
	service list using SDP or discover all primary services.
    \begin{verbatim}
      $ test-device discover <Bluetooth address> [pattern]
    \end{verbatim}
  \item Return the device class (retrieved from
        org.bluez.Device.GetProperties() method which returns all the
        properties of the attached Bluetooth adapter) from a given
        Bluetooth address.
    \begin{verbatim}
      $ test-device class <Bluetooth address>
    \end{verbatim}
  \item Return the device name (retrieved from
        org.bluez.Device.GetProperties() method which returs all the
        properties of the attached Bluetooth adapter) from a given
        Bluetooth address.
    \begin{verbatim}
      $ test-device name <Bluetooth address>
    \end{verbatim}
  \item Return the alias name (retrieved from
        org.bluez.Device.GetProperties() method which returns all the
        properties of the attached Bluetooth adapter) from a given
        Bluetooth address.
    \begin{verbatim}
      $ test-device alias <Bluetooth address> [alias]
    \end{verbatim}
  \item Set the value of the property named ``Trusted'' by passing as
        third argument either the values ``yes'' or ``no''
        (this command also requires an address to be passed as second
         argument).
    \begin{verbatim}
      $ test-device trusted <Bluetooth addres> [yes/no]
    \end{verbatim}
  \item Set the value of the property named ``Blocked'' by passing as
        third argument either the values ``yes'' or ``no''
        (this command also requires an address to be passed as second
         argument).
    \begin{verbatim}
      $ test-device blocked <Bluetooth address> [yes/no]
    \end{verbatim}
\end{enumerate}

The test-attrib is a Python script for testing purposes only and which is part
of the BlueZ toolchain. This script will basically test the Attribute
D-Bus API with Bluetooth LE devices.

There are basically 4 operations that you can perform with test-attrib
script:
\begin{enumerate}
   \item For each Bluetooth LE device, return its address, as well for
     each service of such Bluetooth LE device, and then return the service
     object path, UUID, and all characteristics of it, respectively.
     \begin{verbatim}
       $ test-attrib list
     \end{verbatim}
   \item Return all services from a given Bluetooth address.
     \begin{verbatim}
       $ test-attrib services <Bluetooth address>
     \end{verbatim}
   \item Return all discovery characteristics of the Bluetooth LE device
     from a given service object path.
     \begin{verbatim}
       $ test-attrib discover <Service object path>
     \end{verbatim}
   \item Return all properties from every characteristic of the Bluetooth
     LE Device.
     \begin{verbatim}
       $ test-attrib chars <Service object path>
     \end{verbatim}
\end{enumerate}

describe here test-device, test-attrib, test-adapter and simple-agent

\section{Supporting tools}

explain here l2test, gatttool, hcidump

\end{document}
